# Ethereum Transaction Analysis System Roadmap

## System Architecture
```mermaid
graph TD
    A[Ethereum Blockchain] -->|Pull Latest Block| B[AI Model Analysis]
    B -->|Process Transactions| C[JSON Metadata Array]
    C -->|Hash Data| D[Smart Contract Storage]
    D -->|Store Hash| E[IPFS Publication]
    E -->|Store CID| F[Centralised Database]
    F -->|Serve Data| G[Frontend Application]
```

## 1. Blockchain Data Collection
- Create a script to pull latest block data
- Implement event listeners for new blocks
- Store raw transaction data temporarily

```javascript
// Example block listener
provider.on('block', async (blockNumber) => {
  const block = await provider.getBlock(blockNumber);
  // Process transactions
});
```

## 2. AI Model Analysis
- Process transaction patterns
- Identify transaction types
- Generate metadata
- Output structured JSON

```javascript
// Example metadata structure
{
  transactions: [
    {
      hash: "0x...",
      from: "0x...",
      to: "0x...",
      value: "0.0",
      timestamp: 1234567890,
      type: "normal",
      token: "",
      aiAnalysis: {
        riskScore: 0.5,
        category: "transfer",
        confidence: 0.95
      }
    }
  ]
}
```

## 3. Smart Contract Integration
- Deploy IPFSHashIndex contract
- Implement hash verification
- Store transaction hashes

```solidity
// Key contract functions
function indexContent(bytes32 ipfsCid, string calldata data) 
function verifyData(uint256 contentId, string calldata data)
```

## 4. IPFS Integration
- Set up IPFS node
- Implement CID storage
- Create pinning service

```javascript
// IPFS upload example
const { cid } = await ipfs.add(JSON.stringify(metadata));
await ipfs.pin.add(cid);
```

## 5. Centralised Database
- Design schema:
```sql
CREATE TABLE transactions (
  id SERIAL PRIMARY KEY,
  block_number BIGINT,
  transaction_hash VARCHAR(66),
  ipfs_cid VARCHAR(46),
  on_chain_hash VARCHAR(66),
  metadata JSONB,
  indexed_at TIMESTAMP,
  verified BOOLEAN
);
```
- Implement CRUD operations
- Set up indexing
- Create API endpoints

## 6. Frontend Development
- Create data fetching layer
- Implement verification UI
- Build transaction viewer
- Add real-time updates

## 7. Verification System
```javascript
// Verification flow
async function verifyTransaction(txHash) {
  // 1. Get data from database
  const txData = await db.getTransaction(txHash);
  
  // 2. Get IPFS data
  const ipfsData = await ipfs.cat(txData.ipfs_cid);
  
  // 3. Hash the data
  const dataHash = keccak256(ipfsData);
  
  // 4. Verify on chain
  const isValid = await contract.verifyData(txData.contentId, ipfsData);
  
  return isValid;
}
```

## 8. Development Phases

### Phase 1: Foundation
- Set up development environment
- Deploy smart contract
- Create basic IPFS integration
- Implement database schema

### Phase 2: Core Functionality
- Develop block data collection
- Implement AI analysis
- Create hash verification system
- Build basic frontend

### Phase 3: Integration
- Connect all components
- Implement error handling
- Add logging and monitoring
- Create API endpoints

### Phase 4: Enhancement
- Add real-time updates
- Implement caching
- Optimize performance
- Add advanced features

## 9. Testing Strategy
- Unit tests for each component
- Integration tests for system flow
- End-to-end testing
- Performance testing

## 10. Deployment Pipeline
```
Development -> Testing -> Staging -> Production
```

## Next Steps
1. Set up development environment
2. Deploy initial smart contract
3. Create basic IPFS integration
4. Implement database schema
5. Begin block data collection development

## Notes
- Ensure proper error handling at each step
- Implement logging for debugging
- Consider gas optimization for smart contracts
- Plan for scalability from the start
- Regular security audits recommended 
